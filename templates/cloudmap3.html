<html>

<style>

.q0-9 { fill:rgb(247,251,255); }
.q1-9 { fill:rgb(222,235,247); }
.q2-9 { fill:rgb(198,219,239); }
.q3-9 { fill:rgb(158,202,225); }
.q4-9 { fill:rgb(107,174,214); }
.q5-9 { fill:rgb(66,146,198); }
.q6-9 { fill:rgb(33,113,181); }
.q7-9 { fill:rgb(8,81,156); }
.q8-9 { fill:rgb(8,48,107); }
</style>
 <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.4/leaflet.css" />
 <!--[if lte IE 8]>
     <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.4/leaflet.ie.css" />
 <![endif]-->
<body>


<div id="map" style="width: 700px; height: 700px"></div>

<table>
<tbody id='json-out'>hi hi </tbody>
</table>

<script src="http://cdn.leafletjs.com/leaflet-0.4/leaflet.js"></script>
<script src="http://d3js.org/d3.v3.min.js"></script>
 
<script type="text/javascript">
   // create a map in the "map" div, set the view to a given place and zoom
	var map = L.map('map').setView([49.261111,  -123.253056], 15);

// add an OpenStreetMap tile layer
	L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
	    attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
	}).addTo(map);

var myLayer = L.geoJson().addTo(map);
//myLayer.addData(geojsonFeature);
		
var ubcBuildings; // container for the json data
var buildingLookup = {}; //associative object
var remaining=3; // counter for loading data

// load UBC buildings data asynchronously
// this file was converted from a KML file with UBC building outlines
// the original KML file was created by hand by someone from UBC Ops and provided by Stefan Storey
d3.json('UBC.json', function(error, json){
	if (error) return console.warn(error);
	ubcBuildings = json;
	for (var i = 0; i < ubcBuildings['features'].length; i++) {	
		var regExp = /G\s?RP_ID<\/td> <td>(.*?)<\/td>/;  // regular expression to pull out building ID from description (XML)
		var regExpOut = regExp.exec(ubcBuildings['features'][i]['properties']['Description'])
		if (regExpOut!= null) {
			var bldId = regExp.exec(ubcBuildings['features'][i]['properties']['Description'])[1];
			} else {
			var bldId = ''
		}
		ubcBuildings['features'][i]['properties']['bldId'] = bldId;
	}	
	
	if (!--remaining) go(); // go once all datasets are loaded
})	
	
			
// load building lookup table asynchronously... index by group id	
// this file was generated by hand by Stefan Storey to link KML building outlines to Pulse Energy meters
d3.csv('building-lookup.csv', function(error, json) {
	if (error) return console.warn(error);
	var csvIn = json;		
	for (var i =0; i < csvIn.length; i++) {
		var grpId = csvIn[i]['GRP_ID'];
		buildingLookup[String(grpId)] = csvIn[i];
		// the result is an associative array indexed on GRP_ID (from the KML)
	}
	if (!--remaining) go(); // go once all datasets are loaded
})

var pulseData = {}; 
// load pulse energy data asynchronously... index by pulse id
// this file is a static output from some python code, it will be made dynamic in the future
d3.csv('energy.csv', function(error, json) {
	if (error) return console.warn(error);
	pulseData=json;
	if (!--remaining) go(); // go once all datasets are loaded
})

var maxEnergy=0;

	
function go() {
	myLayer.addData(ubcBuildings); // write buildings	
	// link building-id to energy from pulse dataset
	for (var i=0; i < ubcBuildings['features'].length; i++) {
	ubcBuildings['features'][i]['properties']['energy']=0 // default energy reading
		var bldId = ubcBuildings['features'][i]['properties']['bldId'];
		if (buildingLookup[bldId] != null)
			
			// map pulse ID to energy ID
			// note this is a convoluted way to do it which could be replaced with an SQL query once a local DB exists
			// but i'm using flat static files at the moment in order to get this off the ground quickly
			if (buildingLookup[bldId]['PULSE_ID'] != "") {
				var pulseId = buildingLookup[bldId]['PULSE_ID']
				for (var j =0; j < pulseData.length; j++) {
					if (pulseData[j]['id']==pulseId) {
						var pulseReading = parseFloat(pulseData[j]['sum']);
						if (!isNaN(pulseReading)) {
							ubcBuildings['features'][i]['properties']['energy']=parseFloat(pulseReading);
							if (pulseReading > maxEnergy)
								maxEnergy = pulseReading; // store this to set the color gradient
							
						}
					}	
				
				}
			}
	}
	
	var color = d3.scale.linear()
    .domain([0, maxEnergy])
    .range(["yellow", "red"]);
	
	// adjust building colours
	L.geoJson(ubcBuildings, {
		style: function(feature) {
			
			if (feature.properties.energy==0)
				return {color: "#ffffff"}; // grey
			else if (feature.properties.energy > 0)
				return {color: color(feature.properties.energy), opacity: 1};	// green
			else 
				return {color: "#ff0000"};	// red - should be none 		
		}
	}).addTo(map);
	
}

	
	</script>  
  
</body>
</html>


